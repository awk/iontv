//  recsched_bkgd - Background server application retrieves schedule data, performs recordings,
//  transcodes recordings in to H.264 format for iTunes, iPod etc.
//
//  Copyright (C) 2007 Andrew Kimpton
//
//  This program is free software; you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation; either version 2 of the License, or
//  (at your option) any later version.
//
//  This program is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with this program; if not, write to the Free Software
//  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

/*-
 * WSDL stubs for:  tvDataDelivery.wsdl
 *   Generated by:  awk
 *           Date:  Fri Jan 12 11:21:07 2007
 *        Emitter:  Objective-C
 */

#import "tvDataDelivery.h"
#import "Preferences.h"
#import "RSActivityDisplayProtocol.h"
#import "recsched_bkgd_AppDelegate.h"
#import "RecSchedServer.h"
#import "RSNotifications.h"

#import <Security/Security.h>

// URL for SOAP services used to retrieve the listings
// @"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService


@implementation tvDataDelivery

static CFTypeRef deserializationCallback(WSMethodInvocationRef invocation, CFXMLTreeRef msgRoot, CFXMLTreeRef  deserializeRoot, void *info)
{
  // Create a temp file path - rather than allowing the default WebServices parser to try and handle the returned
  // XML data we just write it to a file and parse it seperately later. The WebServices parser is confused anyway
  // by a lot of the XML in this file and tries to interpret things as SOAP returned variables.
  NSString *xmlFilePath = (NSString *) info;

  // Find the <xtvd ..> portion of the input XML - that's all we need to write out
  CFDataRef dataRef = CFXMLTreeCreateXMLData(kCFAllocatorDefault, deserializeRoot);
  NSError *anXMLParserError = [NSError alloc];
  NSXMLDocument *anXMLDoc = [[NSXMLDocument alloc] initWithData:(NSData*) dataRef options:NSXMLDocumentTidyXML error:&anXMLParserError];
  [anXMLParserError release];
  CFRelease(dataRef);

  NSXMLNode *currentNode = [anXMLDoc rootElement];
  bool foundXTVD = false;
  while (currentNode && !foundXTVD) {
    NSString *nodeName = [currentNode name];
    if (nodeName && ([nodeName compare:@"xtvd" options:NSCaseInsensitiveSearch] == NSOrderedSame)) {
      foundXTVD = true;
    } else {
      currentNode = [currentNode nextNode];
    }
  }

  bool success = false;
  // Write out the piece if found
  if (foundXTVD) {
    [currentNode detach];
    NSXMLElement *xtvdElement = [[NSXMLElement alloc] initWithName:@"xtvd"];
    NSXMLDocument *xtvdXMLDoc = [[NSXMLDocument alloc] initWithRootElement:xtvdElement];
    [xtvdElement release];
    [xtvdXMLDoc setCharacterEncoding:@"UTF-8"];
    [xtvdXMLDoc setVersion:@"1.0"];
    [xtvdXMLDoc setRootElement:currentNode];

    success = [[NSFileManager defaultManager] createFileAtPath:xmlFilePath contents:[xtvdXMLDoc XMLData] attributes:nil];
    [xtvdXMLDoc release];
  }
  [anXMLDoc release];

  // If the write was successful return a dictionary with the output file path as our 'deserialized' response
  NSDictionary *returnedDict;
  if (success) {
    returnedDict = [[NSDictionary alloc] initWithObjects:[NSArray arrayWithObject:xmlFilePath] forKeys:[NSArray arrayWithObject:@"xmlFilePath"]];
  } else {
    returnedDict = [[NSDictionary alloc] init];
  }
  return returnedDict;
}

- (id)init {
  self = [super init];
  if (self != nil) {
    fAuthorizedRef = nil;
  }
  return self;
}

- (void) dealloc {
  if (fAuthorizedRef) {
    CFRelease(fAuthorizedRef);
    fAuthorizedRef = nil;
  }
  [fXMLFilePath release];
  [super dealloc];
}

  // Return the Result object.  If it hasn't
  // been fetched yet, this will asynchronously block
- (NSDictionary *)getResultDictionary {
  if (fResult == NULL) {
    if (fAsyncTarget != NULL) {
      fAsyncTarget = NULL;
      fAsyncSelector = NULL;
    }

    WSMethodInvocationRef invocation = [self getRef];
    CFStringRef wsGeneratedMode = CFSTR("NS-WSSYNC");

    if (fResult == NULL) {
      WSMethodInvocationScheduleWithRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);

      while (fResult == NULL) {
        [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedMode beforeDate:[NSDate distantFuture]];
      }

      WSMethodInvocationUnscheduleFromRunLoop(invocation, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedMode);
    }
    WSMethodInvocationSetCallBack(fRef, NULL, NULL);

    if (fResult == NULL) {
      [self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
    }

    // Check to see if we got an unauthorized error
    CFHTTPMessageRef responseMessage = (CFHTTPMessageRef) [fResult valueForKey:(id)kWSHTTPResponseMessage];
    if (!responseMessage) {
        [self handleError:@"WSMethodInvocationInvoke failed in get response message" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
        return nil;
    }
    int msgCode = CFHTTPMessageGetResponseStatusCode(responseMessage);

    if (msgCode == 401) {
      // We're not authorized - we need to go through a little dance to resend the request with the authorization
      fAuthorizedRef = [self genCreateInvocationRef];
      CFHTTPMessageRef authInvocationMsgRef;
      CFURLRef theURL = CFHTTPMessageCopyRequestURL(responseMessage);
      authInvocationMsgRef =  CFHTTPMessageCreateRequest(NULL, CFSTR("POST"), theURL, kCFHTTPVersion1_1);
      CFRelease(theURL);

      // Fetch the account name from the prefs file, and the password from the keychain
      NSString *accountName = [[[NSUserDefaultsController sharedUserDefaultsController] values] valueForKey:kWebServicesSDUsernameKey];
      if ((accountName == nil) || ([accountName length] == 0)) {
        NSLog(@"No SchedulesDirect username in the application prefs !");
        return nil;
      }
      NSString *password;
      password = [[NSApp delegate] SDPasswordForUsername:accountName];
      if (!password) {
        password = @"";
      }
      CFHTTPMessageAddAuthentication(authInvocationMsgRef, responseMessage, (CFStringRef)accountName, (CFStringRef) password, NULL, false);
      WSMethodInvocationSetProperty(fAuthorizedRef,kWSHTTPMessage,authInvocationMsgRef);
      fResult = NULL;

      CFStringRef wsGeneratedAuthMode = CFSTR("NS-WSSYNCAUTH");
      WSClientContext clientContext;
      memset(&clientContext, 0, sizeof clientContext);
      clientContext.info = fXMLFilePath;
      WSMethodInvocationAddDeserializationOverride(fAuthorizedRef,CFSTR("urn:TMSWebServices"),CFSTR("xtvd"),deserializationCallback, &clientContext);
      WSMethodInvocationScheduleWithRunLoop(fAuthorizedRef, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

      while (fResult == NULL) {
        [[NSRunLoop currentRunLoop] runMode:(NSString *)wsGeneratedAuthMode beforeDate:[NSDate distantFuture]];
      }
      WSMethodInvocationUnscheduleFromRunLoop(fAuthorizedRef, [[NSRunLoop currentRunLoop] getCFRunLoop], wsGeneratedAuthMode);

      if (fResult == NULL) {
        [self handleError:@"WSMethodInvocationInvoke failed in getResultDictionary" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
      }

      responseMessage = (CFHTTPMessageRef) [fResult valueForKey:(id)kWSHTTPResponseMessage];
      if (!responseMessage) {
        [self handleError:@"WSMethodInvocationInvoke failed in get response message" errorString:NULL errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:paramErr];
        return nil;
      }
      msgCode = CFHTTPMessageGetResponseStatusCode(responseMessage);

// Example Error Returns:
//    "/FaultCode" = -1;
//    "/FaultString" = "Your subscription has expired. Please renew your subscription.";
//    "/kWSHTTPResponseMessage" = <CFHTTPMessage 0x962fc0>{url = http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService; status = HTTP/1.1 500 Internal Server Error};
//    "/kWSResultIsFault" = 1;
      if (msgCode == 500) {
        [self handleError:@"WSMethodInvocationInvoke returned internal server error" errorString:[fResult valueForKey:@"/FaultString"] errorDomain:kCFStreamErrorDomainMacOSStatus errorNumber:[[fResult valueForKey:@"/FaultCode"] intValue]];
      }

      CFRelease(authInvocationMsgRef);
      WSMethodInvocationSetCallBack(fAuthorizedRef, NULL, NULL);
    }
  }
  return fResult;
}

- (void) setXMLFilePath:(NSString *)xmlFilePath {
  NSString *oldPath = fXMLFilePath;
  fXMLFilePath = [xmlFilePath retain];
  [oldPath release];
}

@end; /* tvDataDelivery */

/*-
 *   Method Name:  acknowledge
 * Documentation:  <no documentation>
 */
@implementation acknowledge
- (id)resultValue {
    return [[super getResultDictionary] objectForKey: @"downloadTimes"];
}

- (WSMethodInvocationRef)genCreateInvocationRef {
    NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
    return [self createInvocationRef: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"
                          methodName: @"acknowledge"
                            protocol: (NSString*) kWSSOAP2001Protocol
                               style: (NSString*) kWSSOAPStyleRPC
                          soapAction: @"urn:TMSWebServices:xtvdWebService#acknowledge"
                     methodNamespace: @"urn:TMSWebServices"];
}

@end; /* acknowledge */


/*-
 *   Method Name:  download
 * Documentation:  <no documentation>
 */
@implementation download

- (void)setParameters:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */)in_startTime in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */)in_endTime
{
  id _paramValues[] = {
    (id)in_startTime,
    (id)in_endTime,
  };
  NSString* _paramNames[] = {
    @"startTime",
    @"endTime",
  };
  [super setParameters:2 values: _paramValues names: _paramNames];
}

- (id)resultValue {
    return [[super getResultDictionary] objectForKey: @"xtvdResponse"];
}

- (WSMethodInvocationRef) genCreateInvocationRef {
  NSString *endpointURL = [NSString stringWithFormat:@"http://%@%@", kWebServicesSDHostname,kWebServicesSDPath];
  WSMethodInvocationRef anInvocationRef = [self createInvocationRef: endpointURL //@"http://webservices.schedulesdirect.tmsdatadirect.com/schedulesdirect/tvlistings/xtvdService"
                                                         methodName: @"download"
                                                           protocol: (NSString*) kWSSOAP2001Protocol
                                                              style: (NSString*) kWSSOAPStyleRPC
                                                         soapAction: @"urn:TMSWebServices:xtvdWebService#download"
                                                    methodNamespace: @"urn:TMSWebServices"];
  WSMethodInvocationSetParameters(anInvocationRef, (CFDictionaryRef) fParams, (CFArrayRef) fParamOrder);
  return(anInvocationRef);
}

@end; /* download */



@implementation xtvdWebService

+ (id)acknowledge {
  id result = NULL;
  acknowledge* _invocation = [[acknowledge alloc] init];
  result = [[_invocation resultValue] retain];
  [_invocation release];
  return result;
}


+ (id)download:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */)in_startTime
    in_endTime:(CFTypeRef /* Complex type urn:TMSWebServices|dateTime */)in_endTime
   xmlFilePath:(NSString *)xmlFilePath {
  id result = NULL;
  download* _invocation = [[download alloc] init];
  [_invocation setParameters: in_startTime in_endTime:in_endTime];
  [_invocation setXMLFilePath:xmlFilePath];
  result = [[_invocation resultValue] retain];
  [_invocation release];
  return result;
}

@end;

@implementation xtvdDownloadOperation

- (id)initWithXMLFilePath:(NSString*)xmlFilePath
                startDate:(NSDate *)startDate
                  endDate:(NSDate *)endDate
         progressReporter:(NSObject<RSActivityDisplay> *)progressReporter {
  if (self = [super init]) {
    mXMLFilePath = [xmlFilePath retain];
    mStartDate = [startDate retain];
    mEndDate = [endDate retain];
    mProgressReporter = [progressReporter retain];
  }
  return self;
}

- (void)dealloc {
  [mXMLFilePath release];
  [mStartDate release];
  [mEndDate release];
  [mProgressReporter release];
  [super dealloc];
}

- (void)main {
  NSAutoreleasePool *pool = [[NSAutoreleasePool alloc] init];
  size_t activityToken;
  
  activityToken = [mProgressReporter createActivity];
  activityToken = [mProgressReporter setActivity:activityToken infoString:@"Downloading Schedule Data"];
  activityToken = [mProgressReporter setActivity:activityToken progressIndeterminate:YES];
  
  NSDictionary *downloadResult = [xtvdWebService download:mStartDate in_endTime:mEndDate xmlFilePath:mXMLFilePath];
  
  if ((downloadResult == nil) || ([downloadResult valueForKey:@"xtvd"] == nil)) {
    // Error during the download - notify the other side and return
    [[NSDistributedNotificationCenter defaultCenter] postNotificationName:RSDownloadErrorNotification object:RSBackgroundApplication userInfo:downloadResult];
    activityToken = [mProgressReporter setActivity:activityToken progressIndeterminate:NO];
    [mProgressReporter endActivity:activityToken];
    [pool release];
    return;
  }

  activityToken = [mProgressReporter setActivity:activityToken progressIndeterminate:NO];
  [mProgressReporter endActivity:activityToken];

  [downloadResult release];
  [pool release];
}

@end

/*-
 * End of WSDL document at tvDataDelivery.wsdl
 */
